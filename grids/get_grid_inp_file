#!/usr/bin/env python
# This script generates the x-coord, y-coord and bottom depth files
# for ww3_grid.inp
#
#  Qing Li, 20170305

import sys
import numpy as np
from netCDF4 import Dataset
from astropy.io import ascii

def main():
    """
    Read xxx.grid.nc, and save the x-coord, y-coord
        and bottom depth to txt files for ww3_grid.inp
    """
    # check input
    gridlist = ('gx37', 'gx16', 'gx16b', 'gx16b_np', 'gx16b_sp')
    varargin = sys.argv
    narg = len(varargin)
    if narg > 2:
        raise ValueError('Require 1 argument, got {}.'.format(narg-1))
    gridtype = varargin[1]
    if gridtype not in gridlist:
        raise ValueError('Input grid type {} not supported'.format(gridtype))

    # read data
    gridpath = '.'
    inppath = './grid_inp'
    gridname = gridtype.split('_')[0]
    infile = gridpath+'/'+gridname+'.grids.nc'
    ncfile = Dataset(infile,'r')
    nlat = ncfile.dimensions['nlat'].size
    nlon = ncfile.dimensions['nlon'].size
    print('----')
    print('Grid: {}, (nx, ny) = ({}, {})'.format(gridtype, nlon, nlat))
    print('Input file: {}'.format(infile))

    # save x-coord, y-coord, bottom
    if gridtype == 'gx16b_np':
        cutofflat = 45.0
    elif gridtype == 'gx16b_sp':
        cutofflat = -45.0
    else:
        cutofflat = None

    save_var(ncfile, 'TLONG', inppath+'/'+gridtype+'_x.inp', clat=cutofflat)
    save_var(ncfile, 'TLAT',  inppath+'/'+gridtype+'_y.inp', clat=cutofflat)
    save_var(ncfile, 'HT',    inppath+'/'+gridtype+'_bottom.inp', fscale=0.01, clat=cutofflat)
    save_var(ncfile, 'REGION_MASK', inppath+'/'+gridtype+'_mapsta.inp', fscale=0, clat=cutofflat)
    print('----')
    ncfile.close()

def save_var(ncfile, varname, outfile, fscale=1, clat=None):
    """
    Read in variable 'varname' from file 'ncfile' and write it in
        txt file 'outfile'
        fscale is optional: 0 - set non zero values in dat to 1
                            1 - do nothing
                            otherwise - set dat to dat * fscale
        clat is optional: =0 - global
                          >0 and <90 - north pole region cutoff to latitude clat
                          <0 and >-90 - sorth pole region cutoff to latitude clat
                          [clat[0], clat[1]] - regions between latitudes clat[0] and clat[1]
    """
    nlat = ncfile.dimensions['nlat'].size
    nlon = ncfile.dimensions['nlon'].size
    tmp1 = ncfile.variables[varname][:]
    tmp2 = ncfile.variables['TLAT'][:]

    # check dimension
    datasize = tmp1.shape
    if len(datasize) != 2:
        raise ValueError('Dimension of data should be 2')

    ndatx = tmp1.shape[1]
    ndaty = tmp1.shape[0]
    if ndatx == nlon and ndaty == nlat:
        dat0 = tmp1
        lat = tmp2
    elif ndatx == nlat and ndaty == nlon:
        dat0 = tmp1.transpose()
        lat = tmp2.transpose()
    else:
        raise ValueError('Dimensions not match')

    # scale data if applicable
    if fscale == 0:
        dat0 = np.where(dat0 != 0, 1, 0)
    elif fscale != 1:
        dat0 = dat0 * fscale

    # set mininum and maximum latitde
    if clat is None:
        minlat = -90.0
        maxlat = 90.0
    elif np.size(clat) == 1:
        if clat > 0.0:
            minlat = clat
            maxlat = 90.0
        else:
            minlat = -90.0
            maxlat = clat
    elif np.size(clat) == 2:
        minlat = clat[0]
        maxlat = clat[1]

    # check minlat an maxlat
    if minlat < -90.0 or maxlat > 90.0:
        raise ValueError('Invalid cutoff latitude')

    # apply mask on dat
    dat = np.ma.where((lat>minlat) & (lat<maxlat), dat0, -9999.9)

    for i in range(ndaty):
        if np.any(np.equal(dat[i,:], -9999.9)):
            dat[i,:] = None

    write_inp(dat, outfile)

def write_inp(dat, outfile):
    """
    Write out data in a txt file.
        dat: 2 dimensional array of data
        outfile: output filename
    """
    print('Output file: {}'.format(outfile))
    ascii.write(dat, outfile, format='no_header')

if __name__ == "__main__":
    main()
